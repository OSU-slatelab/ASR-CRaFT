#include "CRF_Viterbi.h"


CRF_Viterbi::CRF_Viterbi(CRF_FeatureStream* ftr_strm_in, CRF_Model* crf_in)
	: crf(crf_in),
	  ftr_strm(ftr_strm_in)
{
	this->gb = new CRF_StdGradBuilder(crf_in);
	this->bunch_size=1;
	this->num_ftrs=this->ftr_strm->num_ftrs();
	this->num_labs=this->crf->getNLabs();
	this->ftr_buf = new float[num_ftrs*bunch_size];
	this->lab_buf = new QNUInt32[bunch_size];
}


CRF_Viterbi::~CRF_Viterbi()
{
}

CRF_LabelPath* CRF_Viterbi::bestPath() {
	// Returns the best path through the current segment
	CRF_Seq* cur_seq = NULL;
	CRF_Seq* seq_head = NULL;
	CRF_Seq* next_seq = NULL;
	CRF_Seq* last_seq = NULL;
	double* Mtrans;
	double* Mstate;
	QNUInt32 ftr_count;
		
	int seq_len=0;
	//cout << "Starting Viterbi Best Path: " << endl;
	do {
		// First, read in the next training value from the file
		//	We can read in a "bunch" at a time, then separate them into individual frames
		ftr_count=ftr_strm->read(this->bunch_size,ftr_buf,lab_buf);
		
		//cout << "Feature Count: " << ftr_count << endl;
		for (QNUInt32 i=0; i<ftr_count; i++) {
			//cout << "\tLabel: " << lab_buf[i] << "\tFeas:";
			// Now, separate the bunch into individual frames
			float* new_buf = new float[this->num_ftrs];
			for (QNUInt32 j=0; j<this->num_ftrs; j++) {
				int idx=i*this->num_ftrs+j;
				new_buf[j]=ftr_buf[idx];
				//cout << " " << new_buf[j];
			}
			//cout << endl;
			// Store the current frame/label information in a sequence node
			//	* sequence nodes create a doubly-linked list, with the previous node known at creation time
			next_seq = new CRF_Seq(new_buf,this->num_ftrs,lab_buf[i],crf->getNLabs(),cur_seq);
			seq_len++;
			if (seq_head == NULL)
			{
				seq_head=next_seq;
			}
			if (cur_seq != NULL) {
				cur_seq->setNext(next_seq);
			}
			cur_seq=next_seq;
			//float value=this->gb->computeTransMatrix(cur_seq,crf);
			float value=this->gb->computeTransMatrixLog(cur_seq);
		}
	} while (ftr_count >= this->bunch_size);
	// Alpha values have been computed and we know how long the sequence is.
	// Now we can perform the Viterbi algorithm over the alpha values
		
	typedef float* floatPtr;
	typedef double* doublePtr;
	typedef int* intPtr;
	
	//floatPtr* delta = new floatPtr[seq_len+1];
	doublePtr* delta = new doublePtr[seq_len+1];
	intPtr* psi = new intPtr[seq_len+1];
	
	for (int idx=0; idx<seq_len+1; idx++) {
		delta[idx] = new double[this->num_labs];
		psi[idx] = new int[this->num_labs];
		for (size_t j=0; j<this->num_labs; j++) {
			delta[idx][j]=0;
			psi[idx][j]=0;
		}
	}
		
	cur_seq=seq_head;
	Mtrans=cur_seq->getMtrans();
	Mstate=cur_seq->getMstate();
	
	// Initialization
	for (size_t j=0; j<this->num_labs; j++) {
		//delta[0][j]=log(R[j]);
		delta[0][j]=Mstate[j];
		psi[0][j]=-1;
	}
	
	// Recursion
	int idx=1;
	while (cur_seq != NULL) {
		Mtrans=cur_seq->getMtrans();
		Mstate=cur_seq->getMstate();
		for (size_t j=0; j<this->num_labs; j++) {
			for (size_t i=0; i<this->num_labs; i++) {
				//float dval=log(R[j])+log(M[i*this->num_labs+j]);
				float dval=Mstate[j]+Mtrans[i*this->num_labs+j];
				if (delta[idx][j] < delta[idx-1][i]+dval) {
					delta[idx][j] = delta[idx-1][i]+dval;
					psi[idx][j] = i;
				}
			}
		}
		cur_seq=cur_seq->getNext();
		idx++;
	}
	
	CRF_LabelPath* bestPath = new CRF_LabelPath(seq_len);
	size_t* bp = bestPath->getLabelPath();
	
	int best=0;
	
	float bestValue=delta[seq_len][0];
	
	
	for (size_t j=0; j<this->num_labs; j++) {
		//cout << "Label: " << j << " Delta value " << delta[seq_len][j] << " Best: " << bestValue << endl;
		if (delta[seq_len][j]>bestValue) {
			bestValue=delta[seq_len][j];
			best=j;
		} 
	}
	
	
		
	bp[seq_len-1]=best;
	//cout << "Seq Len: " << seq_len << " Best: " << best << endl;
	
	for (int t=seq_len-2; t>=0; t--) {
		//cout << "Fine in loop: " << t << " BP[t+1]: " << bp[t+1] << " PSI: " << psi[t+1][bp[t+1]] << endl;
		bp[t]=psi[t+1][bp[t+1]]; // Assign to best path the backpointer from the successive best path
	}
	
	for (int idx=0; idx<seq_len+1; idx++) {
		delete[] delta[idx];
		delete[] psi[idx];
	}
		
	cur_seq=seq_head;
	while (cur_seq != NULL) {
		last_seq=cur_seq;
		cur_seq=cur_seq->getNext();
		delete last_seq;
	}
	
	delete[] delta;
	delete[] psi;	

	return bestPath;
}

CRF_LabelPath* CRF_Viterbi::alignPath() {
	// Returns the best path through the current segment, aligned to the hardtarget label sequence
	CRF_Seq* cur_seq = NULL;
	CRF_Seq* seq_head = NULL;
	CRF_Seq* next_seq = NULL;
	CRF_Seq* last_seq = NULL;
	double* alpha;
	double* Mtrans;
	double* Mstate;
			
	size_t ftr_count;
	
	
	QNUInt32 seq_len=0;
	//cout << "Starting Viterbi Best Path: " << endl;
	
	do {
		// First, read in the next training value from the file
		//	We can read in a "bunch" at a time, then separate them into individual frames
		ftr_count=ftr_strm->read(this->bunch_size,this->ftr_buf,this->lab_buf);
		
		//cout << "Feature Count: " << ftr_count << endl;
		for (QNUInt32 i=0; i<ftr_count; i++) {
			//cout << "\tLabel: " << lab_buf[i] << "\tFeas:";
			// Now, separate the bunch into individual frames
			
			float* new_buf = new float[this->num_ftrs];
			for (QNUInt32 j=0; j<this->num_ftrs; j++) {
				int idx=i*this->num_ftrs+j;
				new_buf[j]=this->ftr_buf[idx];
				//cout << " " << new_buf[j];
			}
			//cout << endl;
			// Store the current frame/label information in a sequence node
			//	* sequence nodes create a doubly-linked list, with the previous node known at creation time
			next_seq = new CRF_Seq(new_buf,this->num_ftrs,this->lab_buf[i],crf->getNLabs(),cur_seq);
			seq_len++;
			if (seq_head == NULL)
			{
				seq_head=next_seq;
			}
			if (cur_seq != NULL) {
				cur_seq->setNext(next_seq);
			}
			cur_seq=next_seq;
			//float value=this->gb->computeTransMatrix(cur_seq,crf);
			float value=this->gb->computeTransMatrixLog(cur_seq);
		}
	} while (ftr_count >= this->bunch_size);
	
	
	// Alpha values have been computed and we know how long the sequence is.
	// Next, we need to get the underlying label sequence.  Per-frame labels are stored in the sequence nodes,
	// so we need to collapse this into a higher-level sequence.
	
	QNUInt32* labPath = new QNUInt32[seq_len]; // Maximum size is the length of the sequence
	
	cur_seq=seq_head;
	labPath[0]=cur_seq->getLab();
	QNUInt32 cur_idx=0;
	cur_seq=cur_seq->getNext();
	
	for (QNUInt32 idx=1; idx<seq_len; idx++) {
		QNUInt32 cur_lab=cur_seq->getLab();
		if (cur_lab != labPath[cur_idx]) {
			// Labels are different, increment and store
			cur_idx++;
			labPath[cur_idx]=cur_lab;
		}
		cur_seq=cur_seq->getNext();
	}
	
	QNUInt32 tot_labs=cur_idx+1;
	
	// Now we can perform the Viterbi algorithm over the stored values
	typedef float* floatPtr;
	typedef double* doublePtr;
	typedef int* intPtr;	
	
	//floatPtr* delta = new floatPtr[seq_len+1];
	//floatPtr* hold = new floatPtr[seq_len+1];
	doublePtr* delta = new doublePtr[seq_len+1];
	doublePtr* hold = new doublePtr[seq_len+1];
	intPtr* psi = new intPtr[seq_len+1];
	
	for (QNUInt32 idx=0; idx<seq_len+1; idx++) {
		delta[idx] = new double[tot_labs];
		psi[idx] = new int[tot_labs];
		hold[idx] = new double[tot_labs];
		for (size_t j=0; j<tot_labs; j++) {
			delta[idx][j]=0;
			psi[idx][j]=0;
			hold[idx][j]=0;
		}
	}
		
	cur_seq=seq_head;
	alpha=cur_seq->getAlpha();
	Mtrans=cur_seq->getMtrans();
	Mstate=cur_seq->getMstate();
	

	delta[0][0]=Mstate[labPath[0]];
	psi[0][0]=-1;
	hold[0][0]=delta[0][0];
	
	// Recursion
	QNUInt32 idx=1;
	while (cur_seq != NULL) {
		alpha=cur_seq->getAlpha();
		Mtrans=cur_seq->getMtrans();
		Mstate=cur_seq->getMstate();
		QNUInt32 maxLabel;
		// We want to limit this so that we start at the upper corner
		// and work downwards
		if (idx < tot_labs) {
			maxLabel=idx;
		}
		else {
			maxLabel=tot_labs;
		}
		for (size_t j=0; j<maxLabel; j++) {
			// Each Label can make only one of two transitions - either a transition to itself OR a transition to
			// the next label in the sequence.
			
			// First compute the self transition
			QNUInt32 prev=j;
			QNUInt32 prevIdx = labPath[prev];
			float dval=Mstate[prevIdx]+Mtrans[prevIdx*this->num_labs+prevIdx];
			if (delta[idx][prev] < delta[idx-1][prev]+dval) {
				//cout << "DVAL: " << dval << endl;
				delta[idx][prev] = delta[idx-1][prev]+dval;
				psi[idx][prev] = prev;
				hold[idx][prev] = dval;
			}
			
			// Next, if we are not in the last state we can make a transition to the next state
			// if it's better than the self transition
			if (j < (maxLabel-1)) {
				QNUInt32 next=j+1;
				QNUInt32 nextIdx=labPath[next];
				dval = Mstate[nextIdx]+Mtrans[prevIdx*this->num_labs+nextIdx];
				
				if (delta[idx][next] < delta[idx-1][prev]+dval) {
					delta[idx][next] = delta[idx-1][prev]+dval;
					hold[idx][next] = dval;
					psi[idx][next]=prev;
				}
			}
		}
		cur_seq=cur_seq->getNext();
		idx++;
	}
	
	
	CRF_LabelPath* bestPath = new CRF_LabelPath(seq_len);
	QNUInt32* bp = bestPath->getLabelPath();
	
	CRF_LabelPath* alignPath = new CRF_LabelPath(seq_len);
	QNUInt32* ap = alignPath->getLabelPath();

	// Unlike standard Viterbi, we know which state we have to end in
	//  start from the backpointer there and see the best path that
	//  leads us there.
	
	ap[seq_len-1]=tot_labs-1; //Index of our terminal position is the last label in the sequence
	bp[seq_len-1]=labPath[tot_labs-1];  // bestPath actually stores the associated label number
	
	for (int t=seq_len-2; t>=0; t--) {
		//cout << "Fine in loop: " << t << " BP[t+1]: " << bp[t+1] << " PSI: " << psi[t+1][ap[t+1]];
		ap[t]=psi[t+1][ap[t+1]]; // Assign to best aligned path the backpointer from the successive best aligned path
		//cout << " AP[t+1]: " << ap[t+1] << " AP[t]: " << ap[t] << endl;
		// Check to make sure that we are either making a self transition OR moving back one step
		//  * This shouldn't be necessary - in the loop above we're restricting to these two transitions, but
		//    just in case we're wrong, we'll put some error checking here
		if ((ap[t] != ap[t+1]) && (ap[t] != ap[t+1]-1)) {
			cerr << "ERROR: Skipped Label - moved from label at pos " << ap[t+1] << " to label at pos " << ap[t] << endl;
			exit(-1);
		}
		bp[t]=labPath[ap[t]];  // Assign to best path the associated label
	}
	
	if (ap[0] != 0) {
		// Again, this check just makes sure that we ended at the starting point.  This shouldn't be necessary 
		// either, but just in case there's a bug in the logic above
		cerr << "ERROR: Label at timestep 0 is label at position " << ap[0] << " instead of label at position 0" << endl;
		exit(-1);
	}
	
	for (QNUInt32 idx=0; idx<seq_len+1; idx++) {
		delete[] delta[idx];
		delete[] psi[idx];
		delete[] hold[idx];
	}
	
	cur_seq=seq_head;
	while (cur_seq != NULL) {
		last_seq=cur_seq;
		cur_seq=cur_seq->getNext();
		delete last_seq;
	}
	
	delete[] delta;
	delete[] psi;
	delete[] hold;
	delete[] labPath;
	delete alignPath;
	
	return bestPath;
}
